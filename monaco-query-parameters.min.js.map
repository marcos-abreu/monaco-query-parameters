{"version":3,"sources":["monaco-query-parameters.js"],"names":["root","factory","define","amd","exports","module","require","Monaco","_","Backbone","this","Router","prototype","_routeToRE","_routeToRegExp","route","call","optionalParam","splatParam","namedParam","escapeRegExp","namesPattern","splatMatch","exec","index","namedMatch","paramNames","match","routeRe","toString","slice","flags","lastIndexOf","replace","optional","rtn","RegExp","map","name","substring","namedParameters"],"mappings":"CAAC,SAASA,EAAMC,GACQ,kBAAXC,SAAyBA,OAAOC,IACzCD,QAAQ,SAAU,WAAY,UAAWD,GACb,gBAAZG,SAChBC,OAAOD,QAAUH,EAAQK,QAAQ,UAAWA,QAAQ,YAAaA,QAAQ,WAEzEN,EAAKO,OAASN,EAAQD,EAAKQ,EAAGR,EAAKS,SAAUT,EAAKO,SAEpDG,KAAM,SAASF,EAAGC,EAAUF,GAsB9BA,EAAOI,OAAOC,UAAUC,WAAaN,EAAOI,OAAOC,UAAUE,eAI7DP,EAAOI,OAAOC,UAAUE,eAAiB,SAASC,GAChD,MAAON,GAASE,OAAOC,UAAUE,eAAeE,KAAKN,KAAMK,GAI7D,IAAIE,GAAgB,aAChBC,EAAgB,SAChBC,EAAgB,eAChBC,EAAgB,2BAChBC,EAAe,qBAuDnB,OAjDAZ,GAASE,OAAOC,UAAUE,eAAiB,SAASC,GAClD,GAAIO,GAAcJ,EAAWK,KAAKR,KAAWS,MAAO,IAChDC,EAAcN,EAAWI,KAAKR,KAAWS,MAAO,IAChDE,EAAaX,EAAMY,MAAMN,OAGzBO,EAAUrB,EAAOI,OAAOC,UAAUC,WAAWG,KAAKN,KAAMK,EAI5DA,GAAQa,EAAQC,WAChBd,EAAQA,EAAMe,MAAM,EACpB,IAAIC,GAAQhB,EAAMe,MAAMf,EAAMiB,YAAY,KAC1CjB,GAAQA,EAAMe,MAAM,EAAGf,EAAMiB,YAAY,OAEzCjB,EAAMkB,QAAQb,EAAc,QACnBa,QAAQhB,EAAe,WACvBgB,QAAQd,EAAY,SAASQ,EAAOO,GAClC,MAAOA,GAAWP,EAAQ,iBAK5BM,QAAQf,EAAY,aAE7BH,GAAS,WAGTA,GAAS,aAGT,IAAIoB,GAAM,GAAIC,QAAO,IAAMrB,EAAQ,IAAKgB,EAAMD,MAAM,GAepD,OAZIR,GAAWE,OAAS,IAIpBW,EAAIb,WAFFG,GAAc,EAECH,EAAWE,MAAQC,EAAWD,MAE9B,IAGrBW,EAAIT,WAAalB,EAAE6B,IAAIX,EAAY,SAASY,GAAQ,MAASA,GAAOA,EAAKC,UAAU,GAAKD,IACxFH,EAAIK,gBAAkB9B,KAAK8B,gBAEpBL,GAGF5B","file":"monaco-query-parameters.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['lodash', 'backbone', 'monaco'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('lodash'), require('backbone'), require('monaco'));\n  } else {\n    root.Monaco = factory(root._, root.Backbone, root.Monaco);\n  }\n}(this, function(_, Backbone, Monaco) {\n/*\n    the goal of this script is to make Monaco works with Backbone Query Parameters\n    the problem is that both of them rewrites the _routeToRegExp method in different ways\n\n    Monaco applications will always call the Monaco version, but by using Backbone Query Parameters\n    we want to call BQP version, but still compile the regex with Monaco's version.\n\n    Solution Workflow:\n        - Monaco Router calls Monaco._routeToRegExp\n        - Monaco._routeToRegExp redirects to Backbone._routeToRegExp (our version of BQP._routeToRegExp)\n        - Our version of BQP._routeToRegExp internally calls Monaco method ( saved as Monaco._routeToRE )\n\n    For that you should include:\n        - Backbone\n        - Backbone Query Parameters\n        - Monaco Framework\n        - backbone-query-monaco-bind.js\n*/\n\n\n// saves the original reference to Monaco's _routeToRegExp into a new method of the router instance\nMonaco.Router.prototype._routeToRE = Monaco.Router.prototype._routeToRegExp;\n\n// reverted Monaco to make use of the original Backbone's _routeToRegExp\n// ( in this case our version Backbone Query Parameters )\nMonaco.Router.prototype._routeToRegExp = function(route) {\n  return Backbone.Router.prototype._routeToRegExp.call(this, route);\n};\n\n// required regexp patterns from Backbone Query Parameters\nvar optionalParam = /\\((.*?)\\)/g,\n    splatParam    = /\\*\\w+/g,\n    namedParam    = /(\\(\\?)?:\\w+/g,\n    escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g,\n    namesPattern = /[\\:\\*]([^\\:\\?\\/]+)/g;\n\n// Makes Backbone's _routeToRegExp call Monaco's BQP bind implementation of the method\n// This method is taken from Backbone Query Parameters, but with modifications to call\n// Monaco's method to convert the router into a regular expression, and then manipulate\n// its result.\nBackbone.Router.prototype._routeToRegExp = function(route) {\n  var splatMatch = (splatParam.exec(route) || {index: -1}),\n      namedMatch = (namedParam.exec(route) || {index: -1}),\n      paramNames = route.match(namesPattern) || [];\n\n  // original _routeToRegExp method from Monaco ( saved earlier on this script )\n  var routeRe = Monaco.Router.prototype._routeToRE.call(this, route);\n\n  // convert the routeRe back to a string and append the necessary options\n  // recreating the regex object after\n  route = routeRe.toString(); // get the string for the regexp\n  route = route.slice(2); // removed the first `/^`\n  var flags = route.slice(route.lastIndexOf('/')); // saves any flag\n  route = route.slice(0, route.lastIndexOf('$/')); // remove the last `$/` and flags\n\n  route.replace(escapeRegExp, '\\\\$&')\n          .replace(optionalParam, '(?:$1)?')\n          .replace(namedParam, function(match, optional) {\n             return optional ? match : '([^\\\\/\\\\?]+)';\n          })\n          // `[^??]` is hacking around a regular expression bug under iOS4.\n          // If only `[^?]` is used then paths like signin/photos will fail\n          // while paths with `?` anywhere, like `signin/photos?`, will succeed.\n          .replace(splatParam, '([^??]*?)');\n\n  route += '(\\\\?.*)?';\n\n  // todo: verify if I should add this patter before executing BQP logic or here\n  route += '([\\?]{1}.*)?';\n\n  // route = route.replace('$', '([\\?]{1}.*)?$'); // add the query string pattern\n  var rtn = new RegExp('^' + route + '$', flags.slice(2)); // recreate the regexp object\n\n  // use the rtn value to hold some parameter data\n  if (splatMatch.index >= 0) {\n    // there is a splat\n    if (namedMatch >= 0) {\n      // negative value will indicate there is a splat match before any named matches\n      rtn.splatMatch = splatMatch.index - namedMatch.index;\n    } else {\n      rtn.splatMatch = -1;\n    }\n  }\n  rtn.paramNames = _.map(paramNames, function(name) { return ( name ? name.substring(1) : name ); });\n  rtn.namedParameters = this.namedParameters;\n\n  return rtn;\n};\n\nreturn Monaco;\n}));\n"],"sourceRoot":"/source/"}